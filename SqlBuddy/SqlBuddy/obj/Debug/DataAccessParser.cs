//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\git\Repo\sqlbuddy\SqlBuddy\SqlBuddy\Parsers\DataAccess.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace SqlBuddy.Parsers {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class DataAccessParser : Parser {
	public const int
		T__3=1, T__2=2, T__1=3, T__0=4, BYTE_ORDER_MARK=5, SINGLE_LINE_DOC_COMMENT=6, 
		DELIMITED_DOC_COMMENT=7, NEW_LINE=8, SINGLE_LINE_COMMENT=9, DELIMITED_COMMENT=10, 
		WHITESPACE=11, DATAACCESS=12, FALSE=13, NULL=14, TRUE=15, IDENTIFIER=16, 
		INTEGER_LITERAL=17, LiteralAccess=18, REAL_LITERAL=19, CHARACTER_LITERAL=20, 
		STRING_LITERAL=21, OPEN_BRACE=22, CLOSE_BRACE=23, OPEN_BRACKET=24, CLOSE_BRACKET=25, 
		OPEN_PARENS=26, CLOSE_PARENS=27, DOT=28, COMMA=29, COLON=30, SEMICOLON=31, 
		PLUS=32, MINUS=33, STAR=34, DIV=35, PERCENT=36, AMP=37, BITWISE_OR=38, 
		CARET=39, BANG=40, TILDE=41, ASSIGNMENT=42, LT=43, GT=44, INTERR=45, DOUBLE_COLON=46, 
		OP_COALESCING=47, OP_INC=48, OP_DEC=49, OP_AND=50, OP_OR=51, OP_PTR=52, 
		OP_EQ=53, OP_NE=54, OP_LE=55, OP_GE=56, OP_ADD_ASSIGNMENT=57, OP_SUB_ASSIGNMENT=58, 
		OP_MULT_ASSIGNMENT=59, OP_DIV_ASSIGNMENT=60, OP_MOD_ASSIGNMENT=61, OP_AND_ASSIGNMENT=62, 
		OP_OR_ASSIGNMENT=63, OP_XOR_ASSIGNMENT=64, OP_LEFT_SHIFT=65, OP_LEFT_SHIFT_ASSIGNMENT=66, 
		QUOTE=67, DOUBLE_QUOTE=68, BACK_SLASH=69, DOUBLE_BACK_SLASH=70, SHARP=71;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'classname'", "'connection'", "'transformators'", "'generator'", 
		"'\\u00EF\\u00BB\\u00BF'", "SINGLE_LINE_DOC_COMMENT", "DELIMITED_DOC_COMMENT", 
		"NEW_LINE", "SINGLE_LINE_COMMENT", "DELIMITED_COMMENT", "WHITESPACE", 
		"'dataaccess'", "'false'", "'null'", "'true'", "IDENTIFIER", "INTEGER_LITERAL", 
		"LiteralAccess", "REAL_LITERAL", "CHARACTER_LITERAL", "STRING_LITERAL", 
		"'{'", "'}'", "'['", "']'", "'('", "')'", "'.'", "','", "':'", "';'", 
		"'+'", "'-'", "'*'", "'/'", "'%'", "'&'", "'|'", "'^'", "'!'", "'~'", 
		"'='", "'<'", "'>'", "'?'", "'::'", "'??'", "'++'", "'--'", "'&&'", "'||'", 
		"'->'", "'=='", "'!='", "'<='", "'>='", "'+='", "'-='", "'*='", "'/='", 
		"'%='", "'&='", "'|='", "'^='", "'<<'", "'<<='", "'''", "'\"'", "'\\'", 
		"'\\\\'", "'#'"
	};
	public const int
		RULE_compileUnit = 0, RULE_dataaccess = 1, RULE_properties = 2, RULE_property = 3, 
		RULE_keyword = 4, RULE_identifier = 5, RULE_literal = 6, RULE_boolean_literal = 7, 
		RULE_assignment = 8, RULE_dictionary_initializer = 9, RULE_dictionary_pairs = 10, 
		RULE_dictionary_pair = 11, RULE_literal_list = 12, RULE_literal_list_items = 13, 
		RULE_string_list = 14, RULE_string_list_items = 15;
	public static readonly string[] ruleNames = {
		"compileUnit", "dataaccess", "properties", "property", "keyword", "identifier", 
		"literal", "boolean_literal", "assignment", "dictionary_initializer", 
		"dictionary_pairs", "dictionary_pair", "literal_list", "literal_list_items", 
		"string_list", "string_list_items"
	};

	public override string GrammarFileName { get { return "DataAccess.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


	    protected const int EOF = Eof;

	public DataAccessParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CompileUnitContext : ParserRuleContext {
		public DataaccessContext dataaccess() {
			return GetRuleContext<DataaccessContext>(0);
		}
		public CompileUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileUnit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterCompileUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitCompileUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompileUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompileUnitContext compileUnit() {
		CompileUnitContext _localctx = new CompileUnitContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_compileUnit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 32; dataaccess();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataaccessContext : ParserRuleContext {
		public ITerminalNode CLOSE_BRACE() { return GetToken(DataAccessParser.CLOSE_BRACE, 0); }
		public ITerminalNode OPEN_BRACE() { return GetToken(DataAccessParser.OPEN_BRACE, 0); }
		public PropertiesContext properties() {
			return GetRuleContext<PropertiesContext>(0);
		}
		public ITerminalNode DATAACCESS() { return GetToken(DataAccessParser.DATAACCESS, 0); }
		public DataaccessContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dataaccess; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterDataaccess(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitDataaccess(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDataaccess(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DataaccessContext dataaccess() {
		DataaccessContext _localctx = new DataaccessContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_dataaccess);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 34; Match(DATAACCESS);
			State = 35; Match(OPEN_BRACE);
			State = 36; properties();
			State = 37; Match(CLOSE_BRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertiesContext : ParserRuleContext {
		public PropertyContext property(int i) {
			return GetRuleContext<PropertyContext>(i);
		}
		public PropertyContext[] property() {
			return GetRuleContexts<PropertyContext>();
		}
		public PropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_properties; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterProperties(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitProperties(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProperties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertiesContext properties() {
		PropertiesContext _localctx = new PropertiesContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 42;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__3) | (1L << T__2) | (1L << T__1) | (1L << T__0))) != 0)) {
				{
				{
				State = 39; property();
				}
				}
				State = 44;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyContext : ParserRuleContext {
		public ITerminalNode SEMICOLON() { return GetToken(DataAccessParser.SEMICOLON, 0); }
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public PropertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_property; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterProperty(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitProperty(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProperty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyContext property() {
		PropertyContext _localctx = new PropertyContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_property);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 45; assignment();
			State = 46; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public ITerminalNode FALSE() { return GetToken(DataAccessParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(DataAccessParser.TRUE, 0); }
		public ITerminalNode DATAACCESS() { return GetToken(DataAccessParser.DATAACCESS, 0); }
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 48;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DATAACCESS) | (1L << FALSE) | (1L << TRUE))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(DataAccessParser.IDENTIFIER, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 50; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public ITerminalNode INTEGER_LITERAL() { return GetToken(DataAccessParser.INTEGER_LITERAL, 0); }
		public ITerminalNode NULL() { return GetToken(DataAccessParser.NULL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(DataAccessParser.STRING_LITERAL, 0); }
		public ITerminalNode CHARACTER_LITERAL() { return GetToken(DataAccessParser.CHARACTER_LITERAL, 0); }
		public ITerminalNode REAL_LITERAL() { return GetToken(DataAccessParser.REAL_LITERAL, 0); }
		public Boolean_literalContext boolean_literal() {
			return GetRuleContext<Boolean_literalContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_literal);
		try {
			State = 58;
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 52; boolean_literal();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 53; Match(INTEGER_LITERAL);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 54; Match(REAL_LITERAL);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 55; Match(CHARACTER_LITERAL);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 56; Match(STRING_LITERAL);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 57; Match(NULL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Boolean_literalContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(DataAccessParser.NULL, 0); }
		public ITerminalNode FALSE() { return GetToken(DataAccessParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(DataAccessParser.TRUE, 0); }
		public Boolean_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolean_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterBoolean_literal(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitBoolean_literal(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolean_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Boolean_literalContext boolean_literal() {
		Boolean_literalContext _localctx = new Boolean_literalContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_boolean_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 60;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << FALSE) | (1L << NULL) | (1L << TRUE))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
	 
		public AssignmentContext() { }
		public virtual void CopyFrom(AssignmentContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TransformatorsContext : AssignmentContext {
		public ITerminalNode ASSIGNMENT() { return GetToken(DataAccessParser.ASSIGNMENT, 0); }
		public String_listContext string_list() {
			return GetRuleContext<String_listContext>(0);
		}
		public TransformatorsContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterTransformators(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitTransformators(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransformators(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GeneratorContext : AssignmentContext {
		public ITerminalNode STRING_LITERAL() { return GetToken(DataAccessParser.STRING_LITERAL, 0); }
		public ITerminalNode ASSIGNMENT() { return GetToken(DataAccessParser.ASSIGNMENT, 0); }
		public GeneratorContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterGenerator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitGenerator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGenerator(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ClassNameContext : AssignmentContext {
		public ITerminalNode STRING_LITERAL() { return GetToken(DataAccessParser.STRING_LITERAL, 0); }
		public ITerminalNode ASSIGNMENT() { return GetToken(DataAccessParser.ASSIGNMENT, 0); }
		public ClassNameContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterClassName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitClassName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClassName(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConnectionContext : AssignmentContext {
		public Dictionary_initializerContext dictionary_initializer() {
			return GetRuleContext<Dictionary_initializerContext>(0);
		}
		public ITerminalNode ASSIGNMENT() { return GetToken(DataAccessParser.ASSIGNMENT, 0); }
		public ConnectionContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterConnection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitConnection(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConnection(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_assignment);
		try {
			State = 74;
			switch (_input.La(1)) {
			case T__3:
				_localctx = new ClassNameContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 62; Match(T__3);
				State = 63; Match(ASSIGNMENT);
				State = 64; Match(STRING_LITERAL);
				}
				break;
			case T__2:
				_localctx = new ConnectionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 65; Match(T__2);
				State = 66; Match(ASSIGNMENT);
				State = 67; dictionary_initializer();
				}
				break;
			case T__0:
				_localctx = new GeneratorContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 68; Match(T__0);
				State = 69; Match(ASSIGNMENT);
				State = 70; Match(STRING_LITERAL);
				}
				break;
			case T__1:
				_localctx = new TransformatorsContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 71; Match(T__1);
				State = 72; Match(ASSIGNMENT);
				State = 73; string_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dictionary_initializerContext : ParserRuleContext {
		public ITerminalNode CLOSE_BRACE() { return GetToken(DataAccessParser.CLOSE_BRACE, 0); }
		public Dictionary_pairsContext dictionary_pairs() {
			return GetRuleContext<Dictionary_pairsContext>(0);
		}
		public ITerminalNode OPEN_BRACE() { return GetToken(DataAccessParser.OPEN_BRACE, 0); }
		public Dictionary_initializerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionary_initializer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterDictionary_initializer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitDictionary_initializer(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionary_initializer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dictionary_initializerContext dictionary_initializer() {
		Dictionary_initializerContext _localctx = new Dictionary_initializerContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_dictionary_initializer);
		try {
			State = 82;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 76; Match(OPEN_BRACE);
				State = 77; dictionary_pairs();
				State = 78; Match(CLOSE_BRACE);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 80; Match(OPEN_BRACE);
				State = 81; Match(CLOSE_BRACE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dictionary_pairsContext : ParserRuleContext {
		public ITerminalNode[] COMMA() { return GetTokens(DataAccessParser.COMMA); }
		public Dictionary_pairContext[] dictionary_pair() {
			return GetRuleContexts<Dictionary_pairContext>();
		}
		public Dictionary_pairContext dictionary_pair(int i) {
			return GetRuleContext<Dictionary_pairContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(DataAccessParser.COMMA, i);
		}
		public Dictionary_pairsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionary_pairs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterDictionary_pairs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitDictionary_pairs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionary_pairs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dictionary_pairsContext dictionary_pairs() {
		Dictionary_pairsContext _localctx = new Dictionary_pairsContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_dictionary_pairs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 84; dictionary_pair();
			State = 89;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 85; Match(COMMA);
				State = 86; dictionary_pair();
				}
				}
				State = 91;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dictionary_pairContext : ParserRuleContext {
		public ITerminalNode CLOSE_BRACE() { return GetToken(DataAccessParser.CLOSE_BRACE, 0); }
		public ITerminalNode COMMA() { return GetToken(DataAccessParser.COMMA, 0); }
		public ITerminalNode OPEN_BRACE() { return GetToken(DataAccessParser.OPEN_BRACE, 0); }
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Dictionary_pairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionary_pair; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterDictionary_pair(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitDictionary_pair(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionary_pair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dictionary_pairContext dictionary_pair() {
		Dictionary_pairContext _localctx = new Dictionary_pairContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_dictionary_pair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92; Match(OPEN_BRACE);
			State = 93; identifier();
			State = 94; Match(COMMA);
			State = 95; literal();
			State = 96; Match(CLOSE_BRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Literal_listContext : ParserRuleContext {
		public ITerminalNode CLOSE_BRACE() { return GetToken(DataAccessParser.CLOSE_BRACE, 0); }
		public ITerminalNode OPEN_BRACE() { return GetToken(DataAccessParser.OPEN_BRACE, 0); }
		public Literal_list_itemsContext literal_list_items() {
			return GetRuleContext<Literal_list_itemsContext>(0);
		}
		public Literal_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterLiteral_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitLiteral_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Literal_listContext literal_list() {
		Literal_listContext _localctx = new Literal_listContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_literal_list);
		try {
			State = 104;
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 98; Match(OPEN_BRACE);
				State = 99; literal_list_items();
				State = 100; Match(CLOSE_BRACE);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 102; Match(OPEN_BRACE);
				State = 103; Match(CLOSE_BRACE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Literal_list_itemsContext : ParserRuleContext {
		public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(DataAccessParser.COMMA); }
		public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(DataAccessParser.COMMA, i);
		}
		public Literal_list_itemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal_list_items; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterLiteral_list_items(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitLiteral_list_items(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral_list_items(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Literal_list_itemsContext literal_list_items() {
		Literal_list_itemsContext _localctx = new Literal_list_itemsContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_literal_list_items);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 106; literal();
			State = 111;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 107; Match(COMMA);
				State = 108; literal();
				}
				}
				State = 113;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_listContext : ParserRuleContext {
		public ITerminalNode CLOSE_BRACE() { return GetToken(DataAccessParser.CLOSE_BRACE, 0); }
		public ITerminalNode OPEN_BRACE() { return GetToken(DataAccessParser.OPEN_BRACE, 0); }
		public String_list_itemsContext string_list_items() {
			return GetRuleContext<String_list_itemsContext>(0);
		}
		public String_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterString_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitString_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_listContext string_list() {
		String_listContext _localctx = new String_listContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_string_list);
		try {
			State = 120;
			switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 114; Match(OPEN_BRACE);
				State = 115; string_list_items();
				State = 116; Match(CLOSE_BRACE);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 118; Match(OPEN_BRACE);
				State = 119; Match(CLOSE_BRACE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_list_itemsContext : ParserRuleContext {
		public ITerminalNode[] COMMA() { return GetTokens(DataAccessParser.COMMA); }
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(DataAccessParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(DataAccessParser.STRING_LITERAL, i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(DataAccessParser.COMMA, i);
		}
		public String_list_itemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_list_items; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.EnterString_list_items(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDataAccessListener typedListener = listener as IDataAccessListener;
			if (typedListener != null) typedListener.ExitString_list_items(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDataAccessVisitor<TResult> typedVisitor = visitor as IDataAccessVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_list_items(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_list_itemsContext string_list_items() {
		String_list_itemsContext _localctx = new String_list_itemsContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_string_list_items);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122; Match(STRING_LITERAL);
			State = 127;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 123; Match(COMMA);
				State = 124; Match(STRING_LITERAL);
				}
				}
				State = 129;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3I\x85\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x4\a\x4"+
		"+\n\x4\f\x4\xE\x4.\v\x4\x3\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\a\x3\a\x3\b\x3"+
		"\b\x3\b\x3\b\x3\b\x3\b\x5\b=\n\b\x3\t\x3\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3"+
		"\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x5\nM\n\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3"+
		"\v\x5\vU\n\v\x3\f\x3\f\x3\f\a\fZ\n\f\f\f\xE\f]\v\f\x3\r\x3\r\x3\r\x3\r"+
		"\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xEk\n\xE\x3\xF\x3\xF"+
		"\x3\xF\a\xFp\n\xF\f\xF\xE\xFs\v\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10"+
		"\x3\x10\x5\x10{\n\x10\x3\x11\x3\x11\x3\x11\a\x11\x80\n\x11\f\x11\xE\x11"+
		"\x83\v\x11\x3\x11\x2\x2\x2\x12\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2"+
		"\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\x2\x4\x4"+
		"\x2\xE\xF\x11\x11\x3\x2\xF\x11\x83\x2\"\x3\x2\x2\x2\x4$\x3\x2\x2\x2\x6"+
		",\x3\x2\x2\x2\b/\x3\x2\x2\x2\n\x32\x3\x2\x2\x2\f\x34\x3\x2\x2\x2\xE<\x3"+
		"\x2\x2\x2\x10>\x3\x2\x2\x2\x12L\x3\x2\x2\x2\x14T\x3\x2\x2\x2\x16V\x3\x2"+
		"\x2\x2\x18^\x3\x2\x2\x2\x1Aj\x3\x2\x2\x2\x1Cl\x3\x2\x2\x2\x1Ez\x3\x2\x2"+
		"\x2 |\x3\x2\x2\x2\"#\x5\x4\x3\x2#\x3\x3\x2\x2\x2$%\a\xE\x2\x2%&\a\x18"+
		"\x2\x2&\'\x5\x6\x4\x2\'(\a\x19\x2\x2(\x5\x3\x2\x2\x2)+\x5\b\x5\x2*)\x3"+
		"\x2\x2\x2+.\x3\x2\x2\x2,*\x3\x2\x2\x2,-\x3\x2\x2\x2-\a\x3\x2\x2\x2.,\x3"+
		"\x2\x2\x2/\x30\x5\x12\n\x2\x30\x31\a!\x2\x2\x31\t\x3\x2\x2\x2\x32\x33"+
		"\t\x2\x2\x2\x33\v\x3\x2\x2\x2\x34\x35\a\x12\x2\x2\x35\r\x3\x2\x2\x2\x36"+
		"=\x5\x10\t\x2\x37=\a\x13\x2\x2\x38=\a\x15\x2\x2\x39=\a\x16\x2\x2:=\a\x17"+
		"\x2\x2;=\a\x10\x2\x2<\x36\x3\x2\x2\x2<\x37\x3\x2\x2\x2<\x38\x3\x2\x2\x2"+
		"<\x39\x3\x2\x2\x2<:\x3\x2\x2\x2<;\x3\x2\x2\x2=\xF\x3\x2\x2\x2>?\t\x3\x2"+
		"\x2?\x11\x3\x2\x2\x2@\x41\a\x3\x2\x2\x41\x42\a,\x2\x2\x42M\a\x17\x2\x2"+
		"\x43\x44\a\x4\x2\x2\x44\x45\a,\x2\x2\x45M\x5\x14\v\x2\x46G\a\x6\x2\x2"+
		"GH\a,\x2\x2HM\a\x17\x2\x2IJ\a\x5\x2\x2JK\a,\x2\x2KM\x5\x1E\x10\x2L@\x3"+
		"\x2\x2\x2L\x43\x3\x2\x2\x2L\x46\x3\x2\x2\x2LI\x3\x2\x2\x2M\x13\x3\x2\x2"+
		"\x2NO\a\x18\x2\x2OP\x5\x16\f\x2PQ\a\x19\x2\x2QU\x3\x2\x2\x2RS\a\x18\x2"+
		"\x2SU\a\x19\x2\x2TN\x3\x2\x2\x2TR\x3\x2\x2\x2U\x15\x3\x2\x2\x2V[\x5\x18"+
		"\r\x2WX\a\x1F\x2\x2XZ\x5\x18\r\x2YW\x3\x2\x2\x2Z]\x3\x2\x2\x2[Y\x3\x2"+
		"\x2\x2[\\\x3\x2\x2\x2\\\x17\x3\x2\x2\x2][\x3\x2\x2\x2^_\a\x18\x2\x2_`"+
		"\x5\f\a\x2`\x61\a\x1F\x2\x2\x61\x62\x5\xE\b\x2\x62\x63\a\x19\x2\x2\x63"+
		"\x19\x3\x2\x2\x2\x64\x65\a\x18\x2\x2\x65\x66\x5\x1C\xF\x2\x66g\a\x19\x2"+
		"\x2gk\x3\x2\x2\x2hi\a\x18\x2\x2ik\a\x19\x2\x2j\x64\x3\x2\x2\x2jh\x3\x2"+
		"\x2\x2k\x1B\x3\x2\x2\x2lq\x5\xE\b\x2mn\a\x1F\x2\x2np\x5\xE\b\x2om\x3\x2"+
		"\x2\x2ps\x3\x2\x2\x2qo\x3\x2\x2\x2qr\x3\x2\x2\x2r\x1D\x3\x2\x2\x2sq\x3"+
		"\x2\x2\x2tu\a\x18\x2\x2uv\x5 \x11\x2vw\a\x19\x2\x2w{\x3\x2\x2\x2xy\a\x18"+
		"\x2\x2y{\a\x19\x2\x2zt\x3\x2\x2\x2zx\x3\x2\x2\x2{\x1F\x3\x2\x2\x2|\x81"+
		"\a\x17\x2\x2}~\a\x1F\x2\x2~\x80\a\x17\x2\x2\x7F}\x3\x2\x2\x2\x80\x83\x3"+
		"\x2\x2\x2\x81\x7F\x3\x2\x2\x2\x81\x82\x3\x2\x2\x2\x82!\x3\x2\x2\x2\x83"+
		"\x81\x3\x2\x2\x2\v,<LT[jqz\x81";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace SqlBuddy.Parsers
