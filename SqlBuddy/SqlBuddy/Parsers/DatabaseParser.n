using Nemerle;
using Nemerle.Collections;
using Nemerle.Peg;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Assertions;

using System;
using System.Data;
using System.Collections.Generic;
using System.Linq;
using SqlBuddy.Domain;
using SCG = System.Collections.Generic;

namespace SqlBuddy.Parsers
{
    [PegGrammar(
        Options = EmitDebugSources,
        source,
        grammar {
            source : DatabaseDefinition = whitespace databaseDef whitespace;
            databaseDef : DatabaseDefinition = database space* left_brace space* properties space* right_brace;
            properties = connectionProp / generatorProp / transformProp / classNameProp;
            //identifier = Literal;
            
#region Line terminators

            newLineCharacter = '\n'
                            / '\r'
                            / '\u2028'    /*  line separator       */
                            / '\u2029';   /*  paragraph separator  */
            newLine   = "\r\n" / newLineCharacter;

#endregion

#region White space
            
            whitespace = [Zs]
                    / '\t'
                    / '\v'        /*  vertial tab          */
                    / '\f';       /*  form feed            */

#endregion

#region Spacer

            space : void = whitespace / newLine;

            [InlineAllSubrules]
            sp : void = space*;                      /* optional spacer          */
            Sp : void = !identifierPartCharacters sp; /* identifier break spacer  */

#endregion

#region Literals

          minus          : string = '-';
          nullLiteral    : Literal = "null"Sp;

          booleanLiteral : Literal = ("true" / "false")Sp;

          decimalDigit                        = ['0'..'9'];
          hexDigit                            = ['0'..'9', 'a'..'f', 'A'..'F'];
      
          decimalIntegerLiteral     : Literal = decimalDigit+;
          integerLiteral            : Literal = decimalIntegerLiteral sp;
          negativeIntegerLiteral    : Literal = minus sp decimalDigit+ sp;

          realLiteral_1   : Literal = decimalDigit* "." decimalDigit+;
          realLiteral_2   : Literal = decimalDigit+;
          realLiteral     : Literal = (realLiteral_1 / realLiteral_2) sp;

          unicodeEscapeSequence_u   : VString = "\\u" hexDigit hexDigit hexDigit hexDigit;
          unicodeEscapeSequence_U   : VString = "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit;
          unicodeEscapeSequence     : VString = unicodeEscapeSequence_u / unicodeEscapeSequence_U;
          hexadecimalEscapeSequence : VString = "\\x" hexDigit hexDigit? hexDigit? hexDigit?;
          simpleEscapeSequence      : VString = "\\'" / "\\\\" / "\\0" / "\\a" / "\\b" / "\\f" / "\\n" / "\\r" / "\\t" / "\\v";
          singleCharacter           : VString = !(newLineCharacter / "'" / "\\") [Any];
          character                 : VString = simpleEscapeSequence / unicodeEscapeSequence / hexadecimalEscapeSequence / singleCharacter;
          characterLiteral          : Literal = "'" character "'" sp;
          slashLiteral              : Literal = @"'\'" sp;
          voidLiteral               : void = stringLiteral;

          singleRegularStringLiteralCharacter                = !(newLineCharacter / "'" / "\\") [Any];
          regularStringLiteralCharacterSequence     : VString = singleRegularStringLiteralCharacter+;
          regularStringLiteralPart                  : VString = simpleEscapeSequence
                                                              / unicodeEscapeSequence
                                                              / hexadecimalEscapeSequence
                                                              / regularStringLiteralCharacterSequence;
          regularStringLiteral                      : Literal = "'" regularStringLiteralPart* "'";

          singleVerbatimStringLiteralCharacter               = !"'" [Any];
          verbatimStringLiteralCharacterSequence    : string = singleVerbatimStringLiteralCharacter+;
          quoteEscapeSequence                       : string = "''";
          verbatimStringLiteralPart                 : string = quoteEscapeSequence
                                                              / verbatimStringLiteralCharacterSequence;
          verbatimStringLiteral                     : Literal = "@'" verbatimStringLiteralPart* "'";

          stringLiteral                             : Literal = (regularStringLiteral / verbatimStringLiteral) sp;

          literal : Literal = booleanLiteral / nullLiteral / realLiteral / negativeIntegerLiteral / integerLiteral / characterLiteral / stringLiteral / slashLiteral;
          
          Np : void = 'N';

#endregion

#region Main grammar
      
#region Preparation

            letterCharacter       = [Lu, Ll, Lt, Lm, Lo, Nl];
            combiningCharacter    = [Mn, Mc];
            decimalDigitCharacter = [Nd];
            connectingCharacter   = [Pc];
            formattingCharacter   = [Cf];

            identifierStartCharacter  = letterCharacter / "_";
            identifierPartCharacters  = letterCharacter / decimalDigitCharacter / connectingCharacter / combiningCharacter / formattingCharacter;
            
            left_brace : void = '{';
            right_brace : void = '}';
            left_parenthesis : void = '(';
            right_parenthesis : void = ')';
            left_bracket : void = '[';
            right_bracket : void = ']';
            comma : void = ',';
            
            spchar = '\\' / left_parenthesis / right_parenthesis / comma / left_brace / right_brace / left_bracket / right_bracket;
            
            A = ('a'/'A');
            B = ('b'/'B');
            C = ('c'/'C');
            D = ('d'/'D');
            E = ('e'/'E');
            F = ('f'/'F');
            G = ('g'/'G');
            H = ('h'/'H');
            I = ('i'/'I');
            J = ('j'/'J');
            K = ('k'/'K');
            L = ('l'/'L');
            M = ('m'/'M');
            N = ('n'/'N');
            O = ('o'/'O');
            P = ('p'/'P');
            Q = ('q'/'Q');
            R = ('r'/'R');
            S = ('s'/'S');
            T = ('t'/'T');
            U = ('u'/'U');
            V = ('v'/'V');
            W = ('w'/'W');
            X = ('x'/'X');
            Y = ('y'/'Y');
            Z = ('z'/'Z');

#endregion

#region Reserved words

            database : void = "database";

            keyword = database;

#endregion
           

#endregion

        }
    )]
    public class DatabaseParser
    {
        
        source(_ : NToken, _ : NToken) : DatabaseDefinition
        {
        }
        
#region Literals

    //minus          : string = '-';
    minus(_ : NToken) : string
    {
      "-";
    }

    //nullLiteral    : Literal = "null"S;
    nullLiteral(_null : NToken) : Literal
    {
      Literal.Null()
    }

    //booleanLiteral : Literal = ("true" / "false")S;
    booleanLiteral(val : NToken) : Literal
    {
      Literal.Boolean(bool.Parse(GetText(val)))
    }

    //decimalIntegerLiteral     : Literal = decimalDigit+ integerTypeSuffix?;
    decimalIntegerLiteral(decimalDigits       : NToken) : Literal
    {
      mutable val;
      if (ulong.TryParse(GetText(decimalDigits), out val))
        Literal.Integer(val, false)
      else
        Literal.ErrorOverflow(GetText(decimalDigits))
    }

    //negativeIntegerLiteral    : Literal = minus decimalIntegerLiteral sp;
    negativeIntegerLiteral(_ : string, decimalDigits : NToken) : Literal
    {
      mutable val;
      if (long.TryParse(GetText(decimalDigits), out val))
        Literal.NegativeInteger(-1 * val, false)
      else
        Literal.ErrorOverflow(GetText(decimalDigits))
    }
    
    //realLiteral_1   : Literal = decimalDigit* "." decimalDigit+ exponentPart? realTypeSuffix?;
    realLiteral_1(mantissa1       : NToken,
                  _dot            : NToken,
                  mantissa2       : NToken) : Literal
    {
      def mantissa = GetText(mantissa1) + "." + GetText(mantissa2);
      Literal.Real(mantissa)
    }

    //realLiteral_2   : Literal = decimalDigit+ exponentPart realTypeSuffix?;
    realLiteral_2(mantissa        : NToken) : Literal
    {
      Literal.Real(GetText(mantissa))
    }

    //unicodeEscapeSequence_u   : string = "\\u" hexDigit hexDigit hexDigit hexDigit;
    unicodeEscapeSequence_u(_u : NToken, d1 : NToken, d2 : NToken, d3 : NToken, d4 : NToken) : VToken[string]
    {
      unchecked {
        def x = 
              HexDigit(d1) << 12
          %|  HexDigit(d2) << 8
          %|  HexDigit(d3) << 4
          %|  HexDigit(d4);
        ConvertUtf32(x)
      }
    }

    //unicodeEscapeSequence_U   : char  = "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit;
    unicodeEscapeSequence_U(_U : NToken, d1 : NToken, d2 : NToken, d3 : NToken, d4 : NToken,
                                         d5 : NToken, d6 : NToken, d7 : NToken, d8 : NToken) : VToken[string]
    {
      unchecked {
        def x = 
              HexDigit(d1) << 28
          %|  HexDigit(d2) << 24
          %|  HexDigit(d3) << 20
          %|  HexDigit(d4) << 16
          %|  HexDigit(d5) << 12
          %|  HexDigit(d6) << 8
          %|  HexDigit(d7) << 4
          %|  HexDigit(d8);
        ConvertUtf32(x)
      }
    }

    //hexadecimalEscapeSequence : string = "\\x" hexDigit hexDigit? hexDigit? hexDigit?;
    hexadecimalEscapeSequence(_x : NToken, d1 : NToken, d2 : NToken, d3 : NToken, d4 : NToken) : VToken[string]
    {
      mutable x = HexDigit(d1);
      unless(d2.IsEmpty)
        x = (x << 4) %| HexDigit(d2);
      unless(d3.IsEmpty)
        x = (x << 4) %| HexDigit(d3);
      unless(d4.IsEmpty)
        x = (x << 4) %| HexDigit(d4);
      ConvertUtf32(x)
    }

    //simpleEscapeSequence      : string = "\\'" / "\\\"" / "\\\\" / "\\0" / "\\a" / "\\b" / "\\f" / "\\n" / "\\r" / "\\t" / "\\v";
    simpleEscapeSequence(seq : NToken) : VToken[string]
    {
      VToken(match(GetText(seq)) {
        | "\\'"   => "\'"
        | "\\\\"  => "\\"
        | "\\0"   => "\0"
        | "\\a"   => "\a"
        | "\\b"   => "\b"
        | "\\f"   => "\f"
        | "\\n"   => "\n"
        | "\\r"   => "\r"
        | "\\t"   => "\t"
        | "\\v"   => "\v"
        | s => s
      })
    }

    //singleCharacter           : string = !newLineCharacter !"'" !"\\" any;
    singleCharacter(any : NToken) : VToken[string]
    {
      VToken(GetText(any))
    }

    //characterLiteral  : Literal = "'" character "'" s;
    characterLiteral(_lquot : NToken, character : VToken[string], _rquot : NToken) : Literal
    {
      match(character.Value) {
        | null => Literal.ErrorUnicode(true, [character.Location])
        | x when x.Length != 1 => Literal.ErrorChar()
        | x => Literal.Char(x[0])
      }
    }
    
    //slashLiteral              : Literal = @"'\'" sp;
    slashLiteral(_ : NToken) : Literal
    {
        Literal.Char('\\');
    }

    //regularStringLiteralCharacterSequence     : string  = singleRegularStringLiteralCharacter*;
    regularStringLiteralCharacterSequence(seq : NToken) : VToken[string]
    {
      VToken(GetText(seq))
    }

    //regularStringLiteral                  : Literal = "\"" regularStringLiteralPart* "\"";
    regularStringLiteral(_lquot : NToken, parts : SCG.List[VToken[string]], _rquot : NToken) : Literal
    {
      mutable unicodeErrors = [];
      foreach(part when null == part.Value in parts)
        unicodeErrors ::= part.Location;

      match(unicodeErrors) {
        | [] => 
          def value = match(parts.Count) {
            | 0 => ""
            | 1 => parts[0].Value
            | 2 => string.Concat(parts[0].Value, parts[1].Value)
            | 3 => string.Concat(parts[0].Value, parts[1].Value, parts[2].Value)
            | 4 => string.Concat(parts[0].Value, parts[1].Value, parts[2].Value, parts[3].Value)
            | _ =>
              def sb = System.Text.StringBuilder(parts.Count * 20);
              foreach(part in parts)
                _ = sb.Append(part.Value);
              sb.ToString()
          }
          Literal.String(value, false)

        | _ =>
          Literal.ErrorUnicode(false, unicodeErrors.Rev())
      }
    }

    //verbatimStringLiteralCharacterSequence    : string  = singleVerbatimStringLiteralCharacter*;
    verbatimStringLiteralCharacterSequence(seq : NToken) : string
    {
      GetText(seq)
    }

    //quoteEscapeSequence                         : string  = "\"\"";
    quoteEscapeSequence(_quot_quot : NToken) : string
    {
      "'"
    }

    //verbatimStringLiteral                       : Literal = "@\"" verbatimStringLiteralPart* "\"";
    verbatimStringLiteral(_at_lquot : NToken, parts : SCG.List[string], _rquot : NToken) : Literal
    {
      def value = match(parts.Count) {
        | 0 => ""
        | 1 => parts[0]
        | 2 => string.Concat(parts[0], parts[1])
        | 3 => string.Concat(parts[0], parts[1], parts[2])
        | 4 => string.Concat(parts[0], parts[1], parts[2], parts[3])
        | _ =>
          def sb = System.Text.StringBuilder(parts.Count * 20);
          foreach(part in parts)
            _ = sb.Append(part);
          sb.ToString()
      }
      Literal.String(value, true)
    }

    #region ServiceFuncs

    private HexDigit(t : NToken) : int
    {
        unchecked {
            def c = ParsingSource.Text[t.StartPos];
            if('0' <= c && c <= '9')
                c :> int - '0' :> int
            else if('a' <= c && c <= 'f')
                c :> int - 'a' :> int + 10
            else if('A' <= c && c <= 'F')
                c :> int - 'A' :> int + 10
            else 
                0
        }
    }

    static ConvertUtf32(x : int) : VToken[string]
    {
      unchecked {
        def x = x :> uint;
        if(x < 0x10000u)
          VToken(char.ToString(x :> char))
        else if(x < 0x110000u) {
          def x = x - 0x10000u;
          VToken(string(array[(x / 0x400u + 0xD800u) :> char, (x % 0x400u + 0xDC00u) :> char]))
        } else
          VToken(null)
      }
    }
    
#endregion
    
#endregion
    }
}
